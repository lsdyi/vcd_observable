var he=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function ge(C){return C&&C.__esModule&&Object.prototype.hasOwnProperty.call(C,"default")?C.default:C}var pn={exports:{}};(function(C,we){(function(N,w){C.exports=w()})(he,function(){function N(){return!0}function w(){return!1}function S(){}const J="Argument is not a typed-function.";function K(){function Q(n){return typeof n=="object"&&n!==null&&n.constructor===Object}const hn=[{name:"number",test:function(n){return typeof n=="number"}},{name:"string",test:function(n){return typeof n=="string"}},{name:"boolean",test:function(n){return typeof n=="boolean"}},{name:"Function",test:function(n){return typeof n=="function"}},{name:"Array",test:Array.isArray},{name:"Date",test:function(n){return n instanceof Date}},{name:"RegExp",test:function(n){return n instanceof RegExp}},{name:"Object",test:Q},{name:"null",test:function(n){return n===null}},{name:"undefined",test:function(n){return n===void 0}}],gn={name:"any",test:N,isAny:!0};let j,A,F=0,p={createCount:0};function v(n){const e=j.get(n);if(e)return e;let t='Unknown type "'+n+'"';const r=n.toLowerCase();let a;for(a of A)if(a.toLowerCase()===r){t+='. Did you mean "'+a+'" ?';break}throw new TypeError(t)}function R(n){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"any";const t=e?v(e).index:A.length,r=[];for(let o=0;o<n.length;++o){if(!n[o]||typeof n[o].name!="string"||typeof n[o].test!="function")throw new TypeError("Object with properties {name: string, test: function} expected");const f=n[o].name;if(j.has(f))throw new TypeError('Duplicate type name "'+f+'"');r.push(f),j.set(f,{name:f,test:n[o].test,isAny:n[o].isAny,index:t+o,conversionsTo:[]})}const a=A.slice(t);A=A.slice(0,t).concat(r).concat(a);for(let o=t+r.length;o<A.length;++o)j.get(A[o]).index=o}function V(){j=new Map,A=[],F=0,R([gn],!1)}V(),R(hn);function yn(){let n;for(n of A)j.get(n).conversionsTo=[];F=0}function W(n){const e=A.filter(t=>{const r=j.get(t);return!r.isAny&&r.test(n)});return e.length?e:["any"]}function D(n){return n&&typeof n=="function"&&"_typedFunctionData"in n}function X(n,e,t){if(!D(n))throw new TypeError(J);const r=t&&t.exact,a=Array.isArray(e)?e.join(","):e,o=z(a),f=O(o);if(!r||f in n.signatures){const u=n._typedFunctionData.signatureMap.get(f);if(u)return u}const i=o.length;let c;if(r){c=[];let u;for(u in n.signatures)c.push(n._typedFunctionData.signatureMap.get(u))}else c=n._typedFunctionData.signatures;for(let u=0;u<i;++u){const m=o[u],h=[];let T;for(T of c){const d=G(T.params,u);if(!(!d||m.restParam&&!d.restParam)){if(!d.hasAny){const b=Y(d);if(m.types.some(x=>!b.has(x.name)))continue}h.push(T)}}if(c=h,c.length===0)break}let s;for(s of c)if(s.params.length<=i)return s;throw new TypeError("Signature not found (signature: "+(n.name||"unnamed")+"("+O(o,", ")+"))")}function dn(n,e,t){return X(n,e,t).implementation}function wn(n,e){const t=v(e);if(t.test(n))return n;const r=t.conversionsTo;if(r.length===0)throw new Error("There are no conversions to "+e+" defined.");for(let a=0;a<r.length;a++)if(v(r[a].from).test(n))return r[a].convert(n);throw new Error("Cannot convert "+n+" to "+e)}function O(n){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:",";return n.map(t=>t.name).join(e)}function vn(n){const e=n.indexOf("...")===0,t=(e?n.length>3?n.slice(3):"any":n).split("|").map(o=>v(o.trim()));let r=!1,a=e?"...":"";return{types:t.map(function(o){return r=o.isAny||r,a+=o.name+"|",{name:o.name,typeIndex:o.index,test:o.test,isAny:o.isAny,conversion:null,conversionIndex:-1}}),name:a.slice(0,-1),hasAny:r,hasConversion:!1,restParam:e}}function Tn(n){const e=n.types.map(f=>f.name),t=En(e);let r=n.hasAny,a=n.name;const o=t.map(function(f){const i=v(f.from);return r=i.isAny||r,a+="|"+f.from,{name:f.from,typeIndex:i.index,test:i.test,isAny:i.isAny,conversion:f,conversionIndex:f.index}});return{types:n.types.concat(o),name:a,hasAny:r,hasConversion:o.length>0,restParam:n.restParam}}function Y(n){return n.typeSet||(n.typeSet=new Set,n.types.forEach(e=>n.typeSet.add(e.name))),n.typeSet}function z(n){const e=[];if(typeof n!="string")throw new TypeError("Signatures must be strings");const t=n.trim();if(t==="")return e;const r=t.split(",");for(let a=0;a<r.length;++a){const o=vn(r[a].trim());if(o.restParam&&a!==r.length-1)throw new SyntaxError('Unexpected rest parameter "'+r[a]+'": only allowed for the last parameter');if(o.types.length===0)return null;e.push(o)}return e}function y(n){const e=k(n);return e?e.restParam:!1}function g(n){if(!n||n.types.length===0)return N;if(n.types.length===1)return v(n.types[0].name).test;if(n.types.length===2){const e=v(n.types[0].name).test,t=v(n.types[1].name).test;return function(r){return e(r)||t(r)}}else{const e=n.types.map(function(t){return v(t.name).test});return function(t){for(let r=0;r<e.length;r++)if(e[r](t))return!0;return!1}}}function bn(n){let e,t,r;if(y(n)){e=on(n).map(g);const a=e.length,o=g(k(n)),f=function(i){for(let c=a;c<i.length;c++)if(!o(i[c]))return!1;return!0};return function(i){for(let c=0;c<e.length;c++)if(!e[c](i[c]))return!1;return f(i)&&i.length>=a+1}}else return n.length===0?function(a){return a.length===0}:n.length===1?(t=g(n[0]),function(a){return t(a[0])&&a.length===1}):n.length===2?(t=g(n[0]),r=g(n[1]),function(a){return t(a[0])&&r(a[1])&&a.length===2}):(e=n.map(g),function(a){for(let o=0;o<e.length;o++)if(!e[o](a[o]))return!1;return a.length===e.length})}function G(n,e){return e<n.length?n[e]:y(n)?k(n):null}function q(n,e){const t=G(n,e);return t?Y(t):new Set}function Z(n){return n.conversion===null||n.conversion===void 0}function $(n,e){const t=new Set;return n.forEach(r=>{const a=q(r.params,e);let o;for(o of a)t.add(o)}),t.has("any")?["any"]:Array.from(t)}function nn(n,e,t){let r,a;const o=n||"unnamed";let f=t,i;for(i=0;i<e.length;i++){const m=[];if(f.forEach(h=>{const T=G(h.params,i),d=g(T);(i<h.params.length||y(h.params))&&d(e[i])&&m.push(h)}),m.length===0){if(a=$(f,i),a.length>0){const h=W(e[i]);return r=new TypeError("Unexpected type of argument in function "+o+" (expected: "+a.join(" or ")+", actual: "+h.join(" | ")+", index: "+i+")"),r.data={category:"wrongType",fn:o,index:i,actual:h,expected:a},r}}else f=m}const c=f.map(function(m){return y(m.params)?1/0:m.params.length});if(e.length<Math.min.apply(null,c))return a=$(f,i),r=new TypeError("Too few arguments in function "+o+" (expected: "+a.join(" or ")+", index: "+e.length+")"),r.data={category:"tooFewArgs",fn:o,index:e.length,expected:a},r;const s=Math.max.apply(null,c);if(e.length>s)return r=new TypeError("Too many arguments in function "+o+" (expected: "+s+", actual: "+e.length+")"),r.data={category:"tooManyArgs",fn:o,index:e.length,expectedLength:s},r;const u=[];for(let m=0;m<e.length;++m)u.push(W(e[m]).join("|"));return r=new TypeError('Arguments of type "'+u.join(", ")+'" do not match any of the defined signatures of function '+o+"."),r.data={category:"mismatch",actual:u},r}function en(n){let e=A.length+1;for(let t=0;t<n.types.length;t++)e=Math.min(e,n.types[t].typeIndex);return e}function tn(n){let e=F+1;for(let t=0;t<n.types.length;t++)Z(n.types[t])||(e=Math.min(e,n.types[t].conversionIndex));return e}function xn(n,e){if(n.hasAny){if(!e.hasAny)return .1}else if(e.hasAny)return-.1;if(n.restParam){if(!e.restParam)return .01}else if(e.restParam)return-.01;const t=en(n)-en(e);if(t<0)return-.001;if(t>0)return .001;const r=tn(n),a=tn(e);if(n.hasConversion){if(!e.hasConversion)return(1+r)*1e-6}else if(e.hasConversion)return-(1+a)*1e-6;const o=r-a;return o<0?-1e-7:o>0?1e-7:0}function An(n,e){const t=n.params,r=e.params,a=k(t),o=k(r),f=y(t),i=y(r);if(f&&a.hasAny){if(!i||!o.hasAny)return 1e7}else if(i&&o.hasAny)return-1e7;let c=0,s=0,u;for(u of t)u.hasAny&&++c,u.hasConversion&&++s;let m=0,h=0;for(u of r)u.hasAny&&++m,u.hasConversion&&++h;if(c!==m)return(c-m)*1e6;if(f&&a.hasConversion){if(!i||!o.hasConversion)return 1e5}else if(i&&o.hasConversion)return-1e5;if(s!==h)return(s-h)*1e4;if(f){if(!i)return 1e3}else if(i)return-1e3;const T=(t.length-r.length)*(f?-100:100);if(T!==0)return T;const d=[];let b=0;for(let M=0;M<t.length;++M){const U=xn(t[M],r[M]);d.push(U),b+=U}if(b!==0)return(b<0?-10:10)+b;let x,P=9;const H=P/(d.length+1);for(x of d){if(x!==0)return(x<0?-P:P)+x;P-=H}return 0}function En(n){if(n.length===0)return[];const e=n.map(v);if(n.length===1)return e[0].conversionsTo;const t=new Set(n),r=new Set;for(let o=0;o<e.length;++o)for(const f of e[o].conversionsTo)t.has(f.from)||r.add(f.from);const a=[];for(const o of r){let f=F+1,i=null;for(let c=0;c<e.length;++c)for(const s of e[c].conversionsTo)s.from===o&&s.index<f&&(f=s.index,i=s);a.push(i)}return a}function jn(n,e){let t=e,r="";if(n.some(o=>o.hasConversion)){const o=y(n),f=n.map(Cn);r=f.map(i=>i.name).join(";"),t=function(){const i=[],c=o?arguments.length-1:arguments.length;for(let s=0;s<c;s++)i[s]=f[s](arguments[s]);return o&&(i[c]=arguments[c].map(f[c])),e.apply(this,i)}}let a=t;if(y(n)){const o=n.length-1;a=function(){return t.apply(this,B(arguments,0,o).concat([B(arguments,o)]))}}return r&&Object.defineProperty(a,"name",{value:r}),a}function Cn(n){let e,t,r,a;const o=[],f=[];let i="";n.types.forEach(function(s){s.conversion&&(i+=s.conversion.from+"~>"+s.conversion.to+",",o.push(v(s.conversion.from).test),f.push(s.conversion.convert))}),i?i=i.slice(0,-1):i="pass";let c=s=>s;switch(f.length){case 0:break;case 1:e=o[0],r=f[0],c=function(s){return e(s)?r(s):s};break;case 2:e=o[0],t=o[1],r=f[0],a=f[1],c=function(s){return e(s)?r(s):t(s)?a(s):s};break;default:c=function(s){for(let u=0;u<f.length;u++)if(o[u](s))return f[u](s);return s}}return Object.defineProperty(c,"name",{value:i}),c}function Sn(n){function e(t,r,a){if(r<t.length){const o=t[r];let f=[];if(o.restParam){const i=o.types.filter(Z);i.length<o.types.length&&f.push({types:i,name:"..."+i.map(c=>c.name).join("|"),hasAny:i.some(c=>c.isAny),hasConversion:!1,restParam:!0}),f.push(o)}else f=o.types.map(function(i){return{types:[i],name:i.name,hasAny:i.isAny,hasConversion:i.conversion,restParam:!1}});return In(f,function(i){return e(t,r+1,a.concat([i]))})}else return[a]}return e(n,0,[])}function On(n,e){const t=Math.max(n.length,e.length);for(let i=0;i<t;i++){const c=q(n,i),s=q(e,i);let u=!1,m;for(m of s)if(c.has(m)){u=!0;break}if(!u)return!1}const r=n.length,a=e.length,o=y(n),f=y(e);return o?f?r===a:a>=r:f?r>=a:r===a}function kn(n){return n.map(e=>cn(e)?an(e.referToSelf.callback):fn(e)?sn(e.referTo.references,e.referTo.callback):e)}function Pn(n,e,t){const r=[];let a;for(a of n){let o=t[a];if(typeof o!="number")throw new TypeError('No definition for referenced signature "'+a+'"');if(o=e[o],typeof o!="function")return!1;r.push(o)}return r}function Mn(n,e,t){const r=kn(n),a=new Array(r.length).fill(!1);let o=!0;for(;o;){o=!1;let f=!0;for(let i=0;i<r.length;++i){if(a[i])continue;const c=r[i];if(cn(c))r[i]=c.referToSelf.callback(t),r[i].referToSelf=c.referToSelf,a[i]=!0,f=!1;else if(fn(c)){const s=Pn(c.referTo.references,r,e);s?(r[i]=c.referTo.callback.apply(this,s),r[i].referTo=c.referTo,a[i]=!0,f=!1):o=!0}}if(f&&o)throw new SyntaxError("Circular reference detected in resolving typed.referTo")}return r}function Fn(n){const e=/\bthis(\(|\.signatures\b)/;Object.keys(n).forEach(t=>{const r=n[t];if(e.test(r.toString()))throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.")})}function Dn(n,e){if(p.createCount++,Object.keys(e).length===0)throw new SyntaxError("No signatures provided");p.warnAgainstDeprecatedThis&&Fn(e);const t=[],r=[],a={},o=[];let f;for(f in e){if(!Object.prototype.hasOwnProperty.call(e,f))continue;const l=z(f);if(!l)continue;t.forEach(function(I){if(On(I,l))throw new TypeError('Conflicting signatures "'+O(I)+'" and "'+O(l)+'".')}),t.push(l);const E=r.length;r.push(e[f]);const pe=l.map(Tn);let L;for(L of Sn(pe)){const I=O(L);o.push({params:L,name:I,fn:E}),L.every(me=>!me.hasConversion)&&(a[I]=E)}}o.sort(An);const i=Mn(r,a,_);let c;for(c in a)Object.prototype.hasOwnProperty.call(a,c)&&(a[c]=i[a[c]]);const s=[],u=new Map;for(c of o)u.has(c.name)||(c.fn=i[c.fn],s.push(c),u.set(c.name,c));const m=s[0]&&s[0].params.length<=2&&!y(s[0].params),h=s[1]&&s[1].params.length<=2&&!y(s[1].params),T=s[2]&&s[2].params.length<=2&&!y(s[2].params),d=s[3]&&s[3].params.length<=2&&!y(s[3].params),b=s[4]&&s[4].params.length<=2&&!y(s[4].params),x=s[5]&&s[5].params.length<=2&&!y(s[5].params),P=m&&h&&T&&d&&b&&x;for(let l=0;l<s.length;++l)s[l].test=bn(s[l].params);const H=m?g(s[0].params[0]):w,M=h?g(s[1].params[0]):w,U=T?g(s[2].params[0]):w,zn=d?g(s[3].params[0]):w,Gn=b?g(s[4].params[0]):w,qn=x?g(s[5].params[0]):w,Bn=m?g(s[0].params[1]):w,Hn=h?g(s[1].params[1]):w,Jn=T?g(s[2].params[1]):w,Kn=d?g(s[3].params[1]):w,Qn=b?g(s[4].params[1]):w,Vn=x?g(s[5].params[1]):w;for(let l=0;l<s.length;++l)s[l].implementation=jn(s[l].params,s[l].fn);const Wn=m?s[0].implementation:S,Xn=h?s[1].implementation:S,Yn=T?s[2].implementation:S,Zn=d?s[3].implementation:S,$n=b?s[4].implementation:S,ne=x?s[5].implementation:S,ee=m?s[0].params.length:-1,te=h?s[1].params.length:-1,re=T?s[2].params.length:-1,oe=d?s[3].params.length:-1,se=b?s[4].params.length:-1,ae=x?s[5].params.length:-1,ie=P?6:0,fe=s.length,ce=s.map(l=>l.test),ue=s.map(l=>l.implementation),le=function(){for(let l=ie;l<fe;l++)if(ce[l](arguments))return ue[l].apply(this,arguments);return p.onMismatch(n,arguments,s)};function _(l,E){return arguments.length===ee&&H(l)&&Bn(E)?Wn.apply(this,arguments):arguments.length===te&&M(l)&&Hn(E)?Xn.apply(this,arguments):arguments.length===re&&U(l)&&Jn(E)?Yn.apply(this,arguments):arguments.length===oe&&zn(l)&&Kn(E)?Zn.apply(this,arguments):arguments.length===se&&Gn(l)&&Qn(E)?$n.apply(this,arguments):arguments.length===ae&&qn(l)&&Vn(E)?ne.apply(this,arguments):le.apply(this,arguments)}try{Object.defineProperty(_,"name",{value:n})}catch{}return _.signatures=a,_._typedFunctionData={signatures:s,signatureMap:u},_}function rn(n,e,t){throw nn(n,e,t)}function on(n){return B(n,0,n.length-1)}function k(n){return n[n.length-1]}function B(n,e,t){return Array.prototype.slice.call(n,e,t)}function _n(n,e){for(let t=0;t<n.length;t++)if(e(n[t]))return n[t]}function In(n,e){return Array.prototype.concat.apply([],n.map(e))}function Un(){const n=on(arguments).map(t=>O(z(t))),e=k(arguments);if(typeof e!="function")throw new TypeError("Callback function expected as last argument");return sn(n,e)}function sn(n,e){return{referTo:{references:n,callback:e}}}function an(n){if(typeof n!="function")throw new TypeError("Callback function expected as first argument");return{referToSelf:{callback:n}}}function fn(n){return n&&typeof n.referTo=="object"&&Array.isArray(n.referTo.references)&&typeof n.referTo.callback=="function"}function cn(n){return n&&typeof n.referToSelf=="object"&&typeof n.referToSelf.callback=="function"}function un(n,e){if(!n)return e;if(e&&e!==n){const t=new Error("Function names do not match (expected: "+n+", actual: "+e+")");throw t.data={actual:e,expected:n},t}return n}function Ln(n){let e;for(const t in n)Object.prototype.hasOwnProperty.call(n,t)&&(D(n[t])||typeof n[t].signature=="string")&&(e=un(e,n[t].name));return e}function Nn(n,e){let t;for(t in e)if(Object.prototype.hasOwnProperty.call(e,t)){if(t in n&&e[t]!==n[t]){const r=new Error('Signature "'+t+'" is defined twice');throw r.data={signature:t,sourceFunction:e[t],destFunction:n[t]},r}n[t]=e[t]}}const Rn=p;p=function(n){const e=typeof n=="string",t=e?1:0;let r=e?n:"";const a={};for(let o=t;o<arguments.length;++o){const f=arguments[o];let i={},c;if(typeof f=="function"?(c=f.name,typeof f.signature=="string"?i[f.signature]=f:D(f)&&(i=f.signatures)):Q(f)&&(i=f,e||(c=Ln(f))),Object.keys(i).length===0){const s=new TypeError("Argument to 'typed' at index "+o+" is not a (typed) function, nor an object with signatures as keys and functions as values.");throw s.data={index:o,argument:f},s}e||(r=un(r,c)),Nn(a,i)}return Dn(r||"",a)},p.create=K,p.createCount=Rn.createCount,p.onMismatch=rn,p.throwMismatchError=rn,p.createError=nn,p.clear=V,p.clearConversions=yn,p.addTypes=R,p._findType=v,p.referTo=Un,p.referToSelf=an,p.convert=wn,p.findSignature=X,p.find=dn,p.isTypedFunction=D,p.warnAgainstDeprecatedThis=!0,p.addType=function(n,e){let t="any";e!==!1&&j.has("Object")&&(t="Object"),p.addTypes([n],t)};function ln(n){if(!n||typeof n.from!="string"||typeof n.to!="string"||typeof n.convert!="function")throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");if(n.to===n.from)throw new SyntaxError('Illegal to define conversion from "'+n.from+'" to itself.')}return p.addConversion=function(n){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{override:!1};ln(n);const t=v(n.to),r=t.conversionsTo.find(a=>a.from===n.from);if(r)if(e&&e.override)p.removeConversion({from:r.from,to:n.to,convert:r.convert});else throw new Error('There is already a conversion from "'+n.from+'" to "'+t.name+'"');t.conversionsTo.push({from:n.from,to:t.name,convert:n.convert,index:F++})},p.addConversions=function(n,e){n.forEach(t=>p.addConversion(t,e))},p.removeConversion=function(n){ln(n);const e=v(n.to),t=_n(e.conversionsTo,a=>a.from===n.from);if(!t)throw new Error("Attempt to remove nonexistent conversion from "+n.from+" to "+n.to);if(t.convert!==n.convert)throw new Error("Conversion to remove does not match existing conversion");const r=e.conversionsTo.indexOf(t);e.conversionsTo.splice(r,1)},p.resolve=function(n,e){if(!D(n))throw new TypeError(J);const t=n._typedFunctionData.signatures;for(let r=0;r<t.length;++r)if(t[r].test(e))return t[r];return null},p}var mn=K();return mn})})(pn);var ye=pn.exports,de=ge(ye);export{de as default};
